#!/bin/bash

# @file display_user
#
# Project Clearwater - IMS in the Cloud
# Copyright (C) 2013  Metaswitch Networks Ltd
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version, along with the "Special Exception" for use of
# the program along with SSL, set forth below. This program is distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details. You should have received a copy of the GNU General Public
# License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
# The author can be reached by email at clearwater@metaswitch.com or by
# post at Metaswitch Networks Ltd, 100 Church St, Enfield EN2 6BQ, UK
#
# Special Exception
# Metaswitch Networks Ltd  grants you permission to copy, modify,
# propagate, and distribute a work formed by combining OpenSSL with The
# Software, or a work derivative of such a combination, even if such
# copying, modification, propagation, or distribution would otherwise
# violate the terms of the GPL. You must comply with the GPL in all
# respects for all of the code used other than OpenSSL.
# "OpenSSL" means OpenSSL toolkit software distributed by the OpenSSL
# Project and licensed under the OpenSSL Licenses, or a work based on such
# software and licensed under the OpenSSL Licenses.
# "OpenSSL Licenses" means the OpenSSL License and Original SSLeay License
# under which the OpenSSL Project distributes the OpenSSL toolkit software,
# as those licenses appear in the file LICENSE-OPENSSL.

mydir=$(cd `dirname $0`;pwd)
cwd=$(pwd)
short=0
keep_going=0
quiet=0

cmdname=$0

usage()
{
    printf "\
Usage: $cmdname [OPTION...] <directory-number>[..<directory-number>] <domain>\n\
\n\
Options:\n\
  --hsprov IP:PORT  IP address and port of homestead-prov\n\
  -k, --keep-going  keep going on errors\n\
  -q, --quiet       suppress errors when ignoring them\n\
  -s, --short       less verbose display\n\
  -h, --help        display this usage\n"

    printf "\n"

    exit 0
}

error()
{
    printf "$@"
    printf "\n\n"

    usage
}

params="$(getopt -o hskq -l help,short,keep-going,quiet,hsprov: --name $cmdname -- "$@")"

if [ $? -ne 0 ]
then
    usage
fi

eval set -- "$params"
unset params

while true
do
    case $1 in
	--)
	shift
	break
	;;
	--hsprov)
	export "HSPROV=${2-}"
	shift 2
	;;
	-s|--short)
	let "short=1"
	shift
	;;
	-q|--quiet)
	let "quiet=1"
	shift
	;;
	-k|--keep-going)
	let "keep_going=1"
	shift
	;;
        -h|--help)
        usage
        ;;
        *)
        usage
        ;;
    esac
done

# Get local (signaling) IP and signaling namespace (if any) from config as we
# can't derive these from HSPROV on a split network system (and config will
# always be present on a # Clearwater Core node running these scripts)
#
# Note that SIG_NAMESPACE may not be defined
local_settings=$(find /usr/share/clearwater/homestead/env -name local_settings.py)
if [ ! -z "$local_settings" ]; then
    eval $(python -c "execfile(\"$local_settings\"); print \"LOCAL_IP=%s\nSIG_NAMESPACE=%s\n\" % (LOCAL_IP, SIG_NAMESPACE)")

    if [ -z $LOCAL_IP ]; then
        printf "Error: no LOCAL_IP in local_settings!\n"
        exit 1
    fi

    if [ ! -z $SIG_NAMESPACE ]; then
        # Set up the signaling namespace prefix
        SIG_PREFIX="sudo ip netns exec $SIG_NAMESPACE"
    fi
else
    printf "Error: can't find local_settings.py!\n"
    exit 1
fi

if [[ -z $HSPROV && -d /usr/share/clearwater/homestead/env ]]; then
    eval $(python -c "execfile(\"$local_settings\"); print \"MANAGEMENT_LOCAL_IP=%s\nHTTP_PORT=%s\nHSS_ENABLED=%s\n\" % (MANAGEMENT_LOCAL_IP, HTTP_PORT, HSS_ENABLED)")

    if [ -z $MANAGEMENT_LOCAL_IP ]; then
        printf "Error: no MANAGEMENT_LOCAL_IP in local_settings!\n"
        exit 1
    fi

    if [ -z $HTTP_PORT ]; then
        printf "Error: no HTTP_PORT in local_settings!\n"
        exit 1
    fi

    if [ "$HSS_ENABLED" != "False" ]; then
        printf "Error: HSS is not disabled!\n"
        exit 1
    fi
else
    if [ -z $HSPROV ]; then
	error "Error: homestead-prov address must be specified!"
    fi
    IP=( $(echo $HSPROV|sed -e 's#:# #') )
    MANAGEMENT_LOCAL_IP=${IP[0]}
    HTTP_PORT=${IP[1]}
    if [ -z $HTTP_PORT ]; then
	HTTP_PORT=8889
    fi
    if [ -z $MANAGEMENT_LOCAL_IP ]; then
	error "Error: homestead-prov IP address must be specified!"
    fi
fi

USER=$1
if [ -z $USER ]; then
    error "Error: a user (directory number) must be specified!"
fi
shift
DOMAIN=$1
if [ -z $DOMAIN ]; then
    error "Error: a domain must be specified!"
fi
shift

HSPROV=${MANAGEMENT_LOCAL_IP}:${HTTP_PORT}
HS=${LOCAL_IP}:8888
_USERS=(${USER//,/ })
USERS=()
SIZES=()
for _USER in ${_USERS[@]}; do
    seq_USERS=(${_USER//./ })
    if [ ${#seq_USERS[@]} -eq 1 ]; then
        seq_USERS[1]=${seq_USERS[0]}
    fi
    echo "${seq_USERS[0]}" | egrep -qe "^[+0-9][0-9]*$"
    if [ $? -ne 0 ]; then
	printf "Error: invalid user range - ${seq_USERS[0]}..${seq_USERS[1]}!\n"
	exit 1
    fi
    echo "${seq_USERS[1]}" | egrep -qe "^[+0-9][0-9]*$"
    if [ $? -ne 0 ]; then
	printf "Error: invalid user range - ${seq_USERS[0]}..${seq_USERS[1]}!\n"
	exit 1
    fi
    if [ ${seq_USERS[0]} -gt ${seq_USERS[1]} ]; then
	printf "Error: invalid user range - ${seq_USERS[0]}..${seq_USERS[1]}!\n"
	exit 1
    fi
    if [ ${#seq_USERS[0]} -ne ${#seq_USERS[1]} ]; then
	printf "Error: invalid user range - ${seq_USERS[0]}..${seq_USERS[1]}!\n"
	exit 1
    fi
    SIZES[${#USERS[@]}]=${#seq_USERS[0]}

    let "num=$(echo ${seq_USERS[0]}|sed -e 's#[+]##g'|sed -e 's#^0*##')+1"
    if [ $num -lt 0 ]; then
	printf "Error: invalid user - ${seq_USERS[0]}!\n"
	exit 1
    fi
    let "num=$(echo ${seq_USERS[1]}|sed -e 's#[+]##g'|sed -e 's#^0*##')+1"
    if [ $num -lt 0 ]; then
	printf "Error: invalid user - ${seq_USERS[1]}!\n"
	exit 1
    fi

    seq_USERS[0]=$(echo ${seq_USERS[0]} | sed -e 's#^0*##' | sed -e 's#^[+]0*#+#')
    seq_USERS[1]=$(echo ${seq_USERS[1]} | sed -e 's#^0*##' | sed -e 's#^[+]0*#+#')

    USERS[${#USERS[@]}]="{${seq_USERS[0]}..${seq_USERS[1]}}"
done

let "i=0"
while [ $i -lt ${#USERS[@]} ]; do
    user=${USERS[$i]}
    plus=""
    rplus=""
    let "SIZE=${SIZES[$i]}"
    if [ "${user:1:1}" == "+" ]; then
	plus="%2B"
	rplus="+"
	let "SIZE=$SIZE - 1"
    fi
    for USER in $(eval echo ${USERS[$i]}); do
	rUSER=$rplus$(printf "%0*d" "$SIZE" "$USER")
	USER=$plus$(printf "%0*d" "$SIZE" "$USER")

	public_id=sip:${USER}@${DOMAIN}
	rpublic_id=sip:${rUSER}@${DOMAIN}
	private_id=${USER}@${DOMAIN}
	rprivate_id=${rUSER}@${DOMAIN}

	if [ "$(curl -m5 -s http://${HSPROV}/ping 2>&1)" != "OK" ]; then
	    printf "Error: can't contact homestead-prov @ http://${HSPROV}!\n"
	    exit 1
	fi

	impu=$(curl -m5 -s http://${HSPROV}/impu/${public_id} 2>&1)
	if [[ ${impu:0:1} == "<" ]]; then
	    if [[ "$(curl -m5 -s http://${HSPROV}/impi/${private_id}/digest)" =~ digest_ha1 ]]; then
		public_id=${public_id}

		service_profile=$(curl -m5 -s -D - http://${HSPROV}/public/${public_id}/service_profile)
		if [ $? -ne 0 ]; then
		    if [[ $keep_going == 0 || ( $keep_going != 0 && $quiet == 0 ) ]]; then
			printf "Error: couldn't retrieve server profile for user ${rprivate_id}\n"
		    fi
		    if [ $keep_going -eq 0 ]; then
			exit 1
		    fi
		fi
		service_profile=$(printf "%s" "${service_profile}"|grep "Location:"|awk '{print $2}'|tr '[[:space:]]' ' '|sed -e 's#[[:space:]]##g')
		iFC=$(curl -m5 -s http://${HSPROV}${service_profile}/filter_criteria)

		digest=$(curl -m5 -s http://${HSPROV}/impi/${private_id}/digest|python -c 'import json,sys;obj=json.load(sys.stdin);print obj["digest_ha1"]' 2>&1)

		registered=$(${SIG_PREFIX} curl -s "http://${HS}/impu/${public_id}/reg-data?private_id=${private_id}"|grep RegistrationState|sed -e 's#.*<RegistrationState[>]\([^<]*\).*#\1#')

		if [ $short -eq 0 ]; then
		    echo ${rprivate_id}:
		    echo "  Registration state:"
		    echo "    $registered"
		    echo "  HA1 digest:"
		    echo "    $digest"
		    echo "  iFC:"
		    (
			if [ -z "$iFC" ]; then
			    printf "Error: no iFC for user ${rprivate_id}\n"
			else
			    echo ${iFC}|python -c 'import xml.dom.minidom, sys; print xml.dom.minidom.parse(sys.stdin).toprettyxml()'|sed -e '/^[[:space:]]*$/d'
			fi
		    ) 2>&1 | while IFS='' read -r line; do
			printf "     %s\n" "$line"
		    done
		else
		    printf "%s:%s\n" "${rprivate_id}" "${digest}"
		fi
	    else
		if [[ $keep_going == 0 || ( $keep_going != 0 && $quiet == 0 ) ]]; then
		    printf "Error: no IMPI user ${rprivate_id}\n"
		fi
		if [ $keep_going -eq 0 ]; then
		    exit 1
		fi
	    fi
	else
	    if [[ $keep_going == 0 || ( $keep_going != 0 && $quiet == 0 ) ]]; then
		printf "Error: no IMPU user '%s'\n" "${rpublic_id}"
	    fi
	    if [ $keep_going -eq 0 ]; then
		exit 1
	    fi
	fi
    done
    let "i=$i + 1"
done
